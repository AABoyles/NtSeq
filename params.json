{"name":"NtSeq","tagline":"JavaScript bioinformatics library for nucleotide sequence manipulation and analysis.","body":"# NtSeq\r\n\r\n**NtSeq** is an open source Bioinformatics library written in JavaScript\r\nthat provides DNA sequence manipulation and analysis tools for node and the\r\nbrowser.\r\n\r\nMore specifically, it's a library for dealing with all kinds of nucleotide sequences,\r\nincluding *degenerate nucleotides*. It's built with the developer (and scientist)\r\nin mind with simple, readable methods that are part of the standard molecular\r\nbiologist's vocabulary.\r\n\r\n## Sequence Alignment / Mapping\r\n\r\nAdditionally, **NtSeq** comes with a novel, highly optimized exhaustive sequence\r\nmapping / comparison tool known as **Nt.MatchMap**.\r\n\r\n**Nt.MatchMap** allows you to *find all ungapped alignments between two degenerate nucleotide sequences, ordered by the number of matches*. Also provided is a list of results showing the number of each match count, which can be useful for determining if certain sequences or variations are over-represented in a target genome. (P-values, unfortunately, are out of the scope of this project.)\r\n\r\n**MatchMap** uses bit operations to exhaustively scan a search sequence at a rate of up to 10x faster than a standard naive alignment implementation that uses string comparisons. It can run at a rate of up to **approximately 500,000,000 nucleotide comparisons per second** single-threaded on a 2.4GHz processor.\r\n\r\nAn explanation of the algorithm used will be made available shortly. In the meantime, the code\r\nis open source and MIT-licensed so feel free to figure it out!\r\n\r\nTests and benchmarks are included in this repository which can be easily run from the command line using node / npm. A sample benchmark is also included in this README. :)\r\n\r\nNew to bioinformatics, or never played with a nucleotide sequence before?\r\nCheck out [Nucleic Acid Notation](http://en.wikipedia.org/wiki/Nucleic_acid_notation)\r\nto get started.\r\n\r\n## What can I do with NtSeq?\r\n\r\n- Quickly scan genomic data for target sequences or ungapped relatives using `.mapSequence()`\r\n\r\n- Grab the 5' -> 3' complement of a sequence with `.complement()`\r\n\r\n- Manipulate sequences easily using `.replicate()`, `.deletion()`, `.insertion()`, `.repeat()` and `.polymerize()`\r\n\r\n- Translate your nucleotide sequences in a single line of code using `.translate()` or `.translateFrame()`\r\n\r\n- Quickly determine AT% content with `.content()` or `.fractionalContent()`\r\n\r\n- Grab *approximate* AT% content for degenerate sequences using `.contentATGC()` or `.fractionalContentATGC()`\r\n\r\n- Load FASTA files into memory from your machine (node) with `.loadFASTA()` or from a string if you use an external AJAX request (web) using `.readFASTA()`\r\n\r\n- Save large sequences for easy accession in the future using a new filetype, `.4bnt` that will cut your FASTA file sizes in half with `.save4bnt()` and `.load4bnt()` (**node only**)\r\n\r\n## Installation\r\n\r\n### Node\r\n\r\n**NtSeq** is available as a node package, and can be installed with:\r\n\r\n```\r\n$ npm install ntseq\r\n```\r\n\r\nYou can use NtSeq in your node project by using:\r\n\r\n```javascript\r\nvar Nt = require('ntseq');\r\n```\r\n\r\n(The [node.js version](https://www.npmjs.com/package/ntseq) has some useful\r\nadditional tools as compared to the web version.)\r\n\r\n### Web\r\n\r\nIn order to use NtSeq on a webpage, download `ntseq.js` from the `web` folder of\r\nthis repository and include it in a script tag, like so (assuming it is in the\r\nsame directory as your page):\r\n\r\n```javascript\r\n<script src=\"ntseq.js\"></script>\r\n```\r\n\r\nIf you're new to writing web applications, a sample page that uses NtSeq is\r\navailable as `index.html` (in the `web` directory).\r\n\r\n### Quick Usage\r\n\r\nThe `Nt` namespace contains two constructor methods, `Nt.Seq` and `Nt.MatchMap`.\r\nYou can use these by calling:\r\n\r\n```javascript\r\n// Create and put data into a new nucleotide sequence\r\nvar seqA = new Nt.Seq();\r\nseqA.read('ATGC');\r\n\r\n// Create an RNA sequence - identical to DNA, but RNA will output 'U' instead of 'T'\r\nvar seqB = new Nt.Seq('RNA');\r\nseqB.read('ATGCATGC');\r\n\r\n// Create a MatchMap of seqA aligned against seqB.\r\nvar map = new Nt.MatchMap(seqA, seqB);\r\n\r\n// Additionally, this line is equivalent to the previous\r\nvar map = seqB.mapSequence(seqA);\r\n```\r\n\r\n## Examples\r\n\r\nLet's start with a simple sequence...\r\n\r\n```javascript\r\nvar seq = new Nt.Seq();\r\nseq.read('AATT');\r\n```\r\n\r\nGreat, now I can start playing around with it. :)\r\n\r\n```javascript\r\nvar repeatedSeq = seq.repeat(3);\r\n\r\n// Logs 'AATT'\r\nconsole.log(seq.sequence());\r\n// Logs 'AATTAATTAATT'\r\nconsole.log(repeatedSeq.sequence());\r\n\r\n// Can shorten to one line...\r\nvar gcSeq = (new Nt.Seq()).read('GCGC');\r\n\r\nvar insertedSeq = repeatedSeq.insertion(gcSeq, 4);\r\n\r\n// Logs 'AATTGCGCAATTAATT'\r\nconsole.log(insertedSeq.sequence());\r\n```\r\n\r\nWe can combine sequences together...\r\n\r\n```javascript\r\n// is 'AATTGCGCAATTAATTGCGC'\r\ninsertedSeq.polymerize(gcSeq).sequence();\r\n```\r\n\r\nAnd we find the reverse complement in a flash!\r\n\r\n```javascript\r\nvar complementMe = (new Nt.Seq()).read('CCAATT');\r\n// is 'AATTGG'\r\ncomplementMe.complement().sequence();\r\n```\r\n\r\nTranslating sequences to amino acid sequences is trivial...\r\n\r\n```javascript\r\nvar seq = (new Nt.Seq()).read('ATGCCCGACTGCA');\r\n// Translate at nucleotide offset 0\r\nseq.translate(); // === 'MPDC'\r\n// Translate at nucleotide offset 1\r\nseq.translate(1); // === 'CPTA'\r\n// Translate at nucleotide offset 0, 1 amino acid into the frame\r\nseq.translateFrame(0, 1); // === 'PDC'\r\n```\r\n\r\nDetermine the AT% Content of my sequence... what fraction is A?\r\n\r\n```javascript\r\nseq.fractionalContent()['A'] // === 0.23076923076923078, about 23%!\r\n```\r\n\r\nHmm, well this is a small sequence but I want to find where \"CCCG\" matches\r\n\r\n```javascript\r\nvar seq = (new Nt.Seq()).read('ATGCCCGACTGCA');\r\nvar querySeq = (new Nt.Seq()).read('CCCG');\r\nvar map = seq.mapSequence(querySeq);\r\nmap.best().position; // === 3\r\n```\r\n\r\nWhat about degenerate matching, 'ASTG'?\r\n\r\n```javascript\r\nvar seq = (new Nt.Seq()).read('ATGCCCGACTGCA');\r\nvar querySeq = (new Nt.Seq()).read('ASTG');\r\nvar map = seq.mapSequence(querySeq);\r\nmap.best().position; // === 7\r\n```\r\n\r\nWhat if there are no perfect matches?\r\n\r\n```javascript\r\nvar seq = (new Nt.Seq()).read('ATGCCCGACTGCA');\r\nvar querySeq = (new Nt.Seq()).read('CCCW');\r\nvar map = seq.mapSequence(querySeq);\r\nmap.best().position; // === 3\r\nmap.best().matches; // === 3\r\nmap.best().alignment().sequence(); // === 'CCCG'\r\n\r\n// this is the actual nucleotides that match, gaps for non-matches\r\nmap.best().alignmentMask().sequence(); // === 'CCC-'\r\n\r\n// this is the optimistic sequence that could match both\r\nmap.best().alignmentCover().sequence(); // === 'CCCD'\r\n\r\n// .matchFrequencyData provides the number of times a certain number of matches were\r\n//    found. In this example, the sequence didn't find any matches at 6\r\n//    locations. Keep in mind the sequence attempts to align outside of the\r\n//    upper and lower bounds of the search space.\r\n//      i.e.     ATGC\r\n//             CCCW\r\nmap.matchFrequencyData(); // === [ 6, 8, 3, 2, 0 ]\r\n```\r\n\r\n## Benchmarks and Tests\r\n\r\nNtSeq has a number of integration tests that you can access (after cloning the\r\n  repository).\r\n\r\nRun tests with\r\n\r\n```\r\n$ npm test\r\n```\r\n\r\nAnd run benchmarks with\r\n\r\n```\r\n$ npm run benchmark\r\n```\r\n\r\nYou should get an output that looks (roughly) like the following (taken\r\n  Feb 7th, 2015 on a 2.4GHz processor).\r\n\r\n```\r\nBenchmark         |        naive |       search |   naiveScore |  searchScore\r\n--------------------------------------------------------------------------------\r\n1,000,000, 0%     |          9ms |          3ms |    9.00ns/nt |    3.00ns/nt\r\n10,000,000, 0%    |         63ms |          5ms |    6.30ns/nt |    0.50ns/nt\r\n100,000,000, 0%   |        621ms |         60ms |    6.21ns/nt |    0.60ns/nt\r\n1,000,000, 25%    |         15ms |          6ms |   15.00ns/nt |    6.00ns/nt\r\n10,000,000, 25%   |        124ms |         17ms |   12.40ns/nt |    1.70ns/nt\r\n100,000,000, 25%  |       1249ms |        233ms |   12.49ns/nt |    2.33ns/nt\r\n1,000,000, 50%    |         15ms |          2ms |   15.00ns/nt |    2.00ns/nt\r\n10,000,000, 50%   |        131ms |         20ms |   13.10ns/nt |    2.00ns/nt\r\n100,000,000, 50%  |       1305ms |        234ms |   13.05ns/nt |    2.34ns/nt\r\n1,000,000, 100%   |         14ms |          2ms |   14.00ns/nt |    2.00ns/nt\r\n10,000,000, 100%  |        144ms |         18ms |   14.40ns/nt |    1.80ns/nt\r\n100,000,000, 100% |       1471ms |        240ms |   14.71ns/nt |    2.40ns/nt\r\n```\r\n\r\n**naive** refers to a simple string implementation of exhaustive alignment\r\nmapping (no heuristics), and **search** refers to the **MatchMap** optimized\r\nbit op alignment mapping, providing the same result (no heuristics either!).\r\n\r\nThe scores (lower is better) are calculated by dividing the total execution time\r\n  in nanoseconds by the input size in (*m* x *n* where *m* is search (large)\r\n  sequence length and *n* is query sequence length).\r\n\r\nThe benchmark titles indicate the total size of the search space, and what\r\npercent identity (similarity) the sequences have to one another.\r\n\r\n# Library Reference\r\n\r\n### Nt.Seq\r\n\r\n#### (constructor) Nt.Seq( [optional String seqType] )\r\n\r\nConstruct a new Nt.Seq object. `seqType` can be `'DNA'` or `'RNA'`.\r\n\r\n```javascript\r\nvar seq = (new Nt.Seq());\r\n```\r\n\r\n---\r\n\r\n#### Nt.Seq#read( [String sequenceData] )\r\n\r\nreturns `self`\r\n\r\nReads the sequenceData into the `Nt.Seq` object.\r\n\r\nExpects the sequence data to be read 5' -> 3' (left to right).\r\n\r\n```javascript\r\nseq.read('ATGCATGC');\r\n```\r\n\r\n---\r\n\r\n#### Nt.Seq#readFASTA( [String fastaData] )\r\n\r\nreturns `self`\r\n\r\nReads a lone FASTA file into the `Nt.Seq` object, removing comments\r\nand ignoring line breaks.\r\n\r\n---\r\n\r\n#### Nt.Seq#size()\r\n\r\nreturns `Integer`\r\n\r\nReturns the size (length in nucleotides) of the sequence.\r\n\r\n---\r\n\r\n#### Nt.Seq#sequence()\r\n\r\nreturns `String`\r\n\r\nReturns the nucleotide sequence as a string\r\n\r\n---\r\n\r\n#### Nt.Seq#complement()\r\n\r\nreturns `Nt.Seq`\r\n\r\nCreates a new `Nt.Seq` object with complementary sequence data.\r\n\r\n```javascript\r\nvar seq = (new Nt.Seq()).read('ATGC');\r\nvar complement = seq.complement();\r\n\r\n// Will read: 'GCAT'\r\ncomplement.sequence();\r\n```\r\n\r\n---\r\n\r\n#### Nt.Seq#equivalent( [Nt.Seq compareSequence] )\r\n\r\nreturns `Boolean`\r\n\r\nTells us whether two sequences are equivalent (same nucleotide data and\r\n  type, RNA or DNA).\r\n\r\n---\r\n\r\n#### Nt.Seq#replicate( [optional Integer offset], [optional Integer length] )\r\n\r\nreturns `Nt.Seq`\r\n\r\nCreates a new `Nt.Seq` object, starting at an optional offset and continuing to\r\nthe specified length. If length is unspecified, will continue until the end of\r\nthe sequence.\r\n\r\n---\r\n\r\n#### Nt.Seq#polymerize( [Nt.Seq sequence] )\r\n\r\nreturns `Nt.Seq`\r\n\r\nCreates a new `Nt.Seq` object that is the result of concatenating the current\r\nand provided `sequence` together.\r\n\r\n---\r\n\r\n#### Nt.Seq#insertion( [Nt.Seq insertedSequence], [Integer offset] )\r\n\r\nreturns `Nt.Seq`\r\n\r\nCreates a new `Nt.Seq` object that is the result of inserting `insertedSequence`\r\nat the specified offset.\r\n\r\n---\r\n\r\n#### Nt.Seq#deletion( [Nt.Seq offset], [Integer length] )\r\n\r\nreturns `Nt.Seq`\r\n\r\nCreates a new `Nt.Seq` object that is the result of deleting (removing)\r\nnucleotides from the current sequence beginning at `offset` and continue to\r\n`length`.\r\n\r\n---\r\n\r\n#### Nt.Seq#repeat( [Integer count] )\r\n\r\nreturns `Nt.Seq`\r\n\r\nCreates a new `Nt.Seq` object that is the result of repeating the current\r\nsequence `count` number of times. (0 will return an empty sequence, 1 will\r\n  return an identical sequence.)\r\n\r\n---\r\n\r\n#### Nt.Seq#mask( [Nt.Seq sequence] )\r\n\r\nreturns `Nt.Seq`\r\n\r\nCreates a new `Nt.Seq` object that is the result of aligning the current\r\n  sequence and provided `sequence` and choosing this most pessimistic match\r\n  between nucleotides. (Provides a sequence containing only exactly matching\r\n    nucleotides.)\r\n\r\n  See [Nucleic Acid Notation](http://en.wikipedia.org/wiki/Nucleic_acid_notation) for more information\r\n\r\n```javascript\r\nvar seqA = (new Nt.Seq()).read('ATGC');\r\nvar seqB = (new Nt.Seq()).read('AWTS')\r\n\r\nvar seqC = seqA.mask(seqB);\r\nseqC.sequence(); // === 'AT-C'\r\n```\r\n\r\n---\r\n\r\n#### Nt.Seq#cover( [Nt.Seq sequence] )\r\n\r\nreturns `Nt.Seq`\r\n\r\nCreates a new `Nt.Seq` object that is the result of aligning the current\r\n  sequence and provided `sequence` and choosing this most optimistic match\r\n  between nucleotides. (Provides a sequence that will match both.)\r\n\r\n  See [Nucleic Acid Notation](http://en.wikipedia.org/wiki/Nucleic_acid_notation) for more information\r\n\r\n```javascript\r\nvar seqA = (new Nt.Seq()).read('ATGC');\r\nvar seqB = (new Nt.Seq()).read('AWTS')\r\n\r\nvar seqC = seqA.cover(seqB);\r\nseqC.sequence(); // === 'AWKS'\r\n```\r\n\r\n---\r\n\r\n#### Nt.Seq#content()\r\n\r\nreturns `Object`\r\n\r\nReturns a Object (hash table) containing the frequency counts of nucleotides,\r\n**including degenerate nucleotides (16 results total)**.\r\n\r\n```javascript\r\nvar seqA = (new Nt.Seq()).read('ATGC');\r\n\r\nvar content = seqA.content();\r\n/* Looks like:\r\n  {\r\n    'A': 1, 'T': 1, 'G': 1, 'C': 1, 'S': 0, 'W': 0, 'N': 0 [...]\r\n  }\r\n*/\r\n\r\nvar Acontent = content['A']; // === 1\r\n```\r\n\r\n---\r\n\r\n#### Nt.Seq#fractionalContent()\r\n\r\nreturns `Object`\r\n\r\nReturns a Object (hash table) containing the fraction of nucleotides present in\r\nthe sequence, **including degenerate nucleotides (16 results total)**.\r\n\r\n```javascript\r\nvar seqA = (new Nt.Seq()).read('ATGC');\r\n\r\nvar content = seqA.fractionalContent();\r\n/* Looks like:\r\n  {\r\n    'A': 0.25, 'T': 0.25, 'G': 0.25, 'C': 0.25, 'S': 0, 'W': 0, 'N': 0 [...]\r\n  }\r\n*/\r\n\r\nvar Acontent = content['A']; // === 0.25\r\n```\r\n\r\n---\r\n\r\n#### Nt.Seq#contentATGC()\r\n\r\nreturns `Object`\r\n\r\nReturns a Object (hash table) containing frequency counts of **only the four\r\nnon-degenerate nucleotides**.\r\n\r\n**NOTE:** Degenerate nucleotides are counted as *fractions*\r\nof A, T, G, or C with this method. (N = 0.25 x A, 0.25 x G, 0.25 x T, 0.25 x C).\r\n\r\n```javascript\r\nvar seqA = (new Nt.Seq()).read('ATNN');\r\n\r\nvar content = seqA.contentATGC();\r\n/* Looks like:\r\n  {\r\n    'A': 1.5,\r\n    'T': 1.5,\r\n    'G': 0.5,\r\n    'C': 0.5\r\n  }\r\n*/\r\n\r\nvar Acontent = content['A']; // === 1.5\r\n```\r\n\r\n---\r\n\r\n#### Nt.Seq#fractionalContentATGC()\r\n\r\nreturns `Object`\r\n\r\nReturns a Object (hash table) containing the fraction of **only the four\r\nnon-degenerate nucleotides**.\r\n\r\n**NOTE:** Degenerate nucleotides are counted as *fractions*\r\nof A, T, G, or C with this method. (N = 0.25 x A, 0.25 x G, 0.25 x T, 0.25 x C).\r\n\r\n```javascript\r\nvar seqA = (new Nt.Seq()).read('ATNN');\r\n\r\nvar content = seqA.fractionalContentATGC();\r\n/* Looks like:\r\n  {\r\n    'A': 0.375,\r\n    'T': 0.375,\r\n    'G': 0.125,\r\n    'C': 0.125\r\n  }\r\n*/\r\n\r\nvar Acontent = content['A']; // === 0.375\r\n```\r\n\r\n---\r\n\r\n#### Nt.Seq#translate( [optional Integer offset], [optional Integer length] )\r\n\r\nreturns `String`\r\n\r\nReturns a string containing the Amino Acid sequence represented by the nucleotide\r\nsequence, starting at a nucleotide provided by `offset` and continuing for `length`\r\n**nucleotides (not amino acids!)**. If `offset` is not provided, the entire\r\nsequence will be translated. If `length` is not provided, translation will\r\ncontinue until the end of the sequence.\r\n\r\nSee [Amino Acid Abbreviations](http://en.wikipedia.org/wiki/Amino_acid#Table_of_standard_amino_acid_abbreviations_and_properties) for more details.\r\n\r\n```javascript\r\nvar seq = (new Nt.Seq()).read('ATGCCCGACTGCA');\r\n// Translate at nucleotide offset 0\r\nseq.translate(); // === 'MPDC'\r\n// Translate at nucleotide offset 1\r\nseq.translate(1); // === 'CPTA'\r\n// Translate at nucleotide offset 1, continue for 6 nucleotides (2 AAs)\r\nseq.translate(1, 6); // === 'CP'\r\n```\r\n\r\n---\r\n\r\n#### Nt.Seq#translateFrame( [optional Integer frame], [optional Integer AAoffset], [optional Integer AAlength] )\r\n\r\nreturns `String`\r\n\r\nReturns a string containing the Amino Acid sequence represented by the current\r\nnucleotide sequence. Translation can begin at one of three `frame`s (0, 1 or 2)\r\nand then begin at an Amino Acid specified by `AAoffset` and continuing for `AAlength`\r\nAmino Acids. If `AAoffset` is not provided, the entire sequence will be translated.\r\nIf `AAlength` is not provided, translation will continue until the end of the sequence.\r\n\r\n**NOTE:** Remember the difference! `.translateFrame()` uses **amino acid** offsets,\r\nwhile `.translate()` uses **nucleotide** offsets.\r\n\r\nSee [Amino Acid Abbreviations](http://en.wikipedia.org/wiki/Amino_acid#Table_of_standard_amino_acid_abbreviations_and_properties) for more details.\r\n\r\n```javascript\r\nvar seq = (new Nt.Seq()).read('ATGCCCGACTGCA');\r\n// Translate entire sequence\r\nseq.translateFrame(); // === 'MPDC'\r\n// Translate beginning at frame 1 (offset by 1 nt)\r\nseq.translateFrame(1); // === 'CPTA'\r\n// Translate from frame 1 (offset by 1 nt), start by offset of 1 amino acid\r\n//   and continue for 2 amino acids\r\nseq.translateFrame(1, 1, 2); // === 'PT'\r\n```\r\n\r\n---\r\n\r\n#### Nt.Seq#mapSequence( [Nt.Seq querySequence] )\r\n\r\nreturns `Nt.MatchMap`\r\n\r\nCreates a new `Nt.MatchMap` object using the provided `querySequence` as a search\r\nquery in the larger sequence. Equivalent to `new MatchMap(querySequence, currentSequence)`.\r\n\r\nSee **Nt.MatchMap** for more details.\r\n\r\n```javascript\r\nvar seq = (new Nt.Seq()).read('ATGCCCGACTGCA');\r\nvar querySeq = (new Nt.Seq()).read('TGC');\r\n\r\nvar map = seq.mapSequence(querySeq); // === (new Nt.MatchMap(querySeq, seq))\r\n\r\n```\r\n\r\n---\r\n\r\n#### Nt.Seq#loadFASTA( [String pathname] )\r\n\r\nreturns `self`\r\n\r\n**NODE ONLY**\r\n\r\nWill load sequence data from a FASTA file located at the provided `pathname`\r\n\r\n---\r\n\r\n#### Nt.Seq#load4bnt( [String pathname] )\r\n\r\nreturns `self`\r\n\r\n**NODE ONLY**\r\n\r\nWill load sequence data from a `.4bnt` file located at the provided `pathname`\r\n\r\n(`.4bnt` is short for \"4-bit nucleotide\")\r\n\r\n---\r\n\r\n#### Nt.Seq#save4bnt( [optional String name], [optional String path] )\r\n\r\nreturns `self`\r\n\r\n**NODE ONLY**\r\n\r\nWill save sequence data as `name.4bnt` in a directory located at `path`.\r\n\r\nIf `name` is not provided, it will be automatically generated as `sequence_TIME.4bnt`\r\nwhere `TIME` is the current UNIX timestamp in milliseconds.\r\n\r\nIf `path` is not provided, the directory you're running the process from will be\r\nused.\r\n\r\n(`.4bnt` is short for \"4-bit nucleotide\")\r\n\r\n---\r\n\r\n### Nt.MatchMap\r\n\r\n#### (constructor) Nt.Matchmap( [Nt.Seq querySeq], [Nt.Seq searchSeq] )\r\n\r\nConstruct a new `Nt.MatchMap` object that queries `searchSeq` for matches of\r\n`querySeq`. Performs exhaustive degenerate nucleotide matching at every\r\ncombination of nucleotides and stores the results. Results are ordered by alignment\r\nof position 0 of `querySeq` with a position in `searchSeq` (starting with negative offsets).\r\n\r\n```javascript\r\nvar seq = (new Nt.Seq()).read('ATGCCCGACTGCA');\r\nvar querySeq = (new Nt.Seq()).read('TGC');\r\n\r\nvar map = new Nt.MatchMap(querySeq, seq); // === seq.mapSequence(querySeq);\r\n```\r\n\r\n---\r\n\r\n#### Nt.MatchMap#results( [optional Integer offset], [optional Integer count] )\r\n\r\nreturns `Array (of Object)`\r\n\r\nProvides results in an array, ordered from the leftmost offset (negative alignment\r\n  of `querySeq` relative to `searchSeq`) as element 0.\r\n\r\nObjects returned will be hashes containing the following:\r\n\r\n```javascript\r\n{\r\n  position: [Integer],\r\n  matches: [Integer]\r\n}\r\n```\r\n\r\nWill `Array#slice` on the result array depending on `offset` and `count`.\r\n(Returns subset of the Array).\r\n\r\n---\r\n\r\n#### Nt.MatchMap#best()\r\n\r\nreturns `Nt.MatchResult`\r\n\r\nProvides the best possible alignment match of `querySeq` in `searchSeq` as\r\na new `Nt.MatchResult` object. See **Nt.MatchResult** for more details.\r\n\r\n**NOTE:** There is no guarantee that the sorted results based on matches will be\r\nstable, do not write code that expects this to always be identical given ties\r\nof top match counts.\r\n\r\n---\r\n\r\n#### Nt.MatchMap#top( [Integer count] )\r\n\r\nreturns `Array (of Nt.MatchResult)`\r\n\r\nProvides an Array containing the **best** possible alignment matches of `querySeq`\r\nin `searchSeq` as new `Nt.MatchResult` objects. See **Nt.MatchResult** for more\r\ndetails.\r\n\r\n**NOTE:** There is no guarantee that the sorted results based on matches will be\r\nstable, do not write code that expects this to always be identical given ties\r\nof top match counts.\r\n\r\n```javascript\r\nvar seq = (new Nt.Seq()).read('ATGCCCGACTGCA');\r\nvar querySeq = (new Nt.Seq()).read('TGC');\r\n\r\nvar map = new Nt.MatchMap(querySeq, seq);\r\nvar topArray = map.top(2); // === [ Nt.MatchResult, Nt.MatchResult ]\r\n```\r\n\r\n---\r\n\r\n#### Nt.MatchMap#bottom( [Integer count] )\r\n\r\nreturns `Array (of Nt.MatchResult)`\r\n\r\nProvides an Array containing the **worst** possible alignment matches of `querySeq`\r\nin `searchSeq` as new `Nt.MatchResult` objects. See **Nt.MatchResult** for more\r\ndetails.\r\n\r\n**NOTE:** There is no guarantee that the sorted results based on matches will be\r\nstable, do not write code that expects this to always be identical given ties\r\nof bottom match counts.\r\n\r\n---\r\n\r\n#### Nt.MatchMap#matchFrequencyData()\r\n\r\nreturns `Array (of Integers)`\r\n\r\nProvides an Array containing the frequency distribution of all matches.\r\nThe Array will be the same length as `querySequence.size()`, the *0*-indexed\r\nelement represents the number of times **no (0)** matches were found considering\r\nall possible alignments,  and the *n*-indexed element represents the number of\r\ntimes **n** matches were found considering all possible alignments.\r\n\r\n\r\n---\r\n\r\n### Nt.MatchResult\r\n\r\n#### INACCESSIBLE (constructor) Nt.MatchResult\r\n\r\nCreate `Nt.MatchResult` using the `Nt.MatchMap#best`, `Nt.MatchMap#top` and\r\n`Nt.MatchMap#bottom` methods.\r\n\r\n#### Properties\r\n\r\n##### .position\r\n\r\n  The alignment position of this MatchResult in `searchSequence` of your\r\n  `Nt.MatchMap`.\r\n\r\n##### .matches\r\n\r\n  The number of matches between `querySequence` and `searchSequence` at this\r\n  alignment position.\r\n\r\n---\r\n\r\n#### Nt.MatchResult#alignment()\r\n\r\nreturns `Nt.Seq`\r\n\r\nCreates a new `Nt.Seq` instance representing the portion of your `searchSequence`\r\naligned at the associated `Nt.MatchResult` position. Will be `querySequence.size()`\r\nnucleotides long.\r\n\r\n```javascript\r\nvar seq = (new Nt.Seq()).read('ATGCCCGACTGCA');\r\nvar querySeq = (new Nt.Seq()).read('TGCTC');\r\n\r\nvar map = new Nt.MatchMap(querySeq, seq);\r\nvar bestMatch = map.best();\r\n\r\nbestMatch.alignment().sequence(); // === 'TGCCC'\r\n```\r\n\r\n---\r\n\r\n#### Nt.MatchResult#alignmentMask()\r\n\r\nreturns `Nt.Seq`\r\n\r\nCreates a new `Nt.Seq` instance representing a `Nt.Seq#mask()` of the portion of your `searchSequence` aligned at the associated `Nt.MatchResult` position.\r\nWill be `querySequence.size()` nucleotides long.\r\n\r\nSee **Nt.Seq#mask** for more information.\r\n\r\n```javascript\r\nvar seq = (new Nt.Seq()).read('ATGCCCGACTGCA');\r\nvar querySeq = (new Nt.Seq()).read('TGCTC');\r\n\r\nvar map = new Nt.MatchMap(querySeq, seq);\r\nvar bestMatch = map.best();\r\n\r\nbestMatch.alignmentMask().sequence(); // === 'TGC-C'\r\n```\r\n\r\n---\r\n\r\n#### Nt.MatchResult#alignmentCover()\r\n\r\nreturns `Nt.Seq`\r\n\r\nCreates a new `Nt.Seq` instance representing a `Nt.Seq#cover()` of the portion of your `searchSequence` aligned at the associated `Nt.MatchResult` position.\r\nWill be `querySequence.size()` nucleotides long.\r\n\r\nSee **Nt.Seq#cover** for more information.\r\n\r\n```javascript\r\nvar seq = (new Nt.Seq()).read('ATGCCCGACTGCA');\r\nvar querySeq = (new Nt.Seq()).read('TGCTC');\r\n\r\nvar map = new Nt.MatchMap(querySeq, seq);\r\nvar bestMatch = map.best();\r\n\r\nbestMatch.alignmentCover().sequence(); // === 'TGCYC'\r\n```\r\n\r\n---\r\n\r\n# Appendix\r\n\r\n## Background\r\n\r\nThe initial purpose for developing this library was to find all sequences similar\r\nto a consensus sequence for a protein's DNA-binding domain in a genome. It was\r\nhypothesized that this protein could act to inhibit transcription by occluding\r\nthe binding of RNA polymerase in multiple locations. I wanted a tool that could\r\ngenerate a list of all of these potential sites of inhibition (sites that the\r\nprotein could potentially bind) ordered by their similarity to a consensus\r\nsequence.\r\n\r\nI had previous experimental results listing a number of nucleotide sequences\r\nthat this DNA-binding domain had high-affinity for. I had to use multiple tools\r\nto A) generate the consensus from identified binding sequences for this protein,\r\nB) use BLAST to try and find sequences that matched. Unfortunately, BLAST did\r\nnot support the use the degenerate consensus sequence that I felt would give the\r\nbest and largest set of results (potential binding sites in the genome) to test.\r\n\r\nUsing **NtSeq**, the `Nt.Seq#cover` method can generate consensus sequences\r\nquickly (though the resulting sequence is unweighted), and `Nt.MatchMap`\r\nsupports degenerate nucleotide matching and can provide *all* ungapped matches\r\n(ordered by relevance) of moderately-sized query sequences in the genomic data\r\nI was looking through (~200kbp) in milliseconds.\r\n\r\nThis project sat unfinished for years, and I felt the need to clean it up and\r\nrelease it. I hope a new generation of young scientists and developers will be\r\nhelp develop and permeate small, focused, well-documented open source JavaScript\r\nlibraries to create beautiful online experiences. :)\r\n\r\n## The Future, p-Values and Over / Under-Represented Sequences\r\n\r\nThough it is outside of the scope of this project, I have done some work on\r\ndetermining whether sequences in a genome are over- or under-represented in a\r\ngenome based on the statistical likelihood of finding a specific frequency of\r\n*k* matches given the ATGC content of the genome and search sequence. (i.e.\r\nHow many times would I expect to find sequence identity of 15 (*k*) of 20\r\nnucleotides if I aligned my query sequence at every possible location in a\r\ngenome?)\r\n\r\n*Between non-degenerate sequences*, you can approximate each alignment check between\r\ntwo nucleotides as a [Bernoulli trial](http://en.wikipedia.org/wiki/Bernoulli_trial),\r\nwhere your probability of success (a match) is based upon the chance of randomly\r\nmatching a nucleotide from your query sequence with your search sequence (for\r\nevenly-distributed ATGC content this is 0.25).\r\n\r\nYou can calculate the probability of matching two nucleotides for your input\r\nsequences by just calculating a sum of probabilities:\r\n\r\n```\r\n  Pr(match) = (Pr(SeqA, 'A') * Pr(SeqB, 'A')) +\r\n    (Pr(SeqA, 'T') * Pr(SeqB, 'T')) +\r\n    (Pr(SeqA, 'G') * Pr(SeqB, 'G')) +\r\n    (Pr(SeqA, 'C') * Pr(SeqB, 'C'));\r\n```\r\n\r\nWhere `Pr(SeqA, 'A')` would be the fractional A content of SeqA. (The\r\nprobability of randomly choosing an 'A' nucleotide in SeqA). (This is available\r\nfrom `Nt.Seq#fractionalContentATGC`).\r\n\r\nYou can then calculate the probability of getting exactly *k* matches on any\r\none alignment (say 15 of 20 for a length-20 query sequence) using the\r\nProbability Mass Function of a [Binomial Distribution](http://en.wikipedia.org/wiki/Binomial_distribution).\r\n\r\nI've written an approximation for calculating the binomial distribution\r\nprobability mass function in JavaScript as follows:\r\n\r\n**p** is the probability of a match between two randomly selected nucleotides\r\n  (calculated above).\r\n\r\n**n** is the number of trials (the length of your query sequence)\r\n\r\n**k** should be your number of matches.\r\n\r\n```javascript\r\nfunction binomialPMF(p, n, k) {\r\n\r\n  /*\r\n    k = # of matches\r\n    n = # of trials (length of query sequence)\r\n    p = probability of success on a given trial\r\n  */\r\n\r\n  if (p === 0) {\r\n    return 0;\r\n  }\r\n\r\n  if (p === 1) {\r\n    return k === n ? 1 : 0;\r\n  }\r\n\r\n  // use symmetry\r\n  if (k > (n / 2)) {\r\n    k = n - k;\r\n    p = 1 - p;\r\n  };\r\n\r\n  /*\r\n    Binomial PMF:\r\n\r\n      (n! / (k! * (n - k)!)) * p^k * (1 - p)^(n - k)\r\n\r\n    Take the natural logarithm so we can add floats instead of multiply ints\r\n    Lose some sensitivity, but if we don't, JS will overflow Number type\r\n\r\n      log(n! / (k! * (n - k)!)) + (k * log(p)) + ((n - k) * log(1 - p))\r\n\r\n  */\r\n  var r = logBinomial(n, k) + (k * Math.log(p)) + ((n - k) * Math.log(1 - p));\r\n\r\n  return Math.exp(r);\r\n\r\n}\r\n\r\nfunction logBinomial(n, k) {\r\n\r\n  var r = 0;\r\n  var i;\r\n\r\n  /*\r\n\r\n    (n! / (k! * (n - k)!)) can be represented as\r\n    Product (i = (n - k + 1) to n): ( i / (n - i + 1) )\r\n\r\n    i.e. n = 5, k = 2\r\n      5! / (2! * 3!) = (5 * 4) / (2 * 1) = (4/2) * (5/1)\r\n\r\n    Can be represented in log form as\r\n    Sum (i = (n - k + 1) to n): ( log(i) - log(n - i + 1) )\r\n\r\n  */\r\n\r\n  for (i = n - k + 1; i <= n; i++) {\r\n    r += Math.log(i) - Math.log(n - i + 1);\r\n  }\r\n\r\n  return r;\r\n\r\n};\r\n```\r\n\r\nYou can use `Nt.MatchMap#matchFrequencyData()` to view your match frequencies.\r\nYou can calculate the probability of finding that many matches on a given\r\nrandom alignment trial by using `binomialPMF(probability_match,\r\nmatchFrequencyData[i], querySeq.size())`. (Where i is the number of matches).\r\nWe can then approximate the number of *expected* frequencies for each match\r\namount by multiplying this by `searchSeq.size() + querySeq.size()` (the number\r\nof actual trials, `Nt.MatchMap` uses negative alignment offsets) by your\r\nprobability result from `binomialPMF`.\r\n\r\nI have not included this work in the library at present time, as it represents\r\nonly a preliminary entry into determining the statistical significance of\r\nsequence match count frequencies. It is nowhere near complete, and if anybody\r\ncan offer additional insight it would be great to extend the library further\r\nto offer useful p-values to scientists. It is important to note that this\r\napproach only provides a useful model when mapping and comparing two\r\n*non-degenerate* sequences.\r\n\r\n## Acknowledgements\r\n\r\nThanks for reading. Hope it's helpful!\r\nThis library is MIT-licensed and completely open source. Use it (and any part\r\nof it) wherever you'd like, but credit is always appreciated. :)\r\n\r\nYou can feel free to follow me on Twitter:\r\n\r\n[@keithwhor](http://twitter.com/keithwhor)\r\n\r\nCheck out my other projects on GitHub:\r\n\r\n[github.com/keithwhor](http://github.com/keithwhor)\r\n\r\nOr check out my personal website:\r\n\r\n[keithwhor.com](http://keithwhor.com)\r\n","google":"UA-44899638-8","note":"Don't delete this file! It's used internally to help with page regeneration."}